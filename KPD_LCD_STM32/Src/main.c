/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "Stm32_F103C6_gpio_driver.h"
#include "stm32f103c6.h"
#include "../Lcd/Lcd.h"
#include "../KPD/KPD_interface.h"

#define SEVEN_SEG_PORT 		GPIOB
#define a_7SEG 				GPIO_PIN_8
#define b_7SEG 				GPIO_PIN_9
#define c_7SEG 				GPIO_PIN_10
#define d_7SEG 				GPIO_PIN_11
#define e_7SEG 				GPIO_PIN_12
#define f_7SEG 				GPIO_PIN_13
#define g_7SEG 				GPIO_PIN_14


uint8_t sevSegArray[11] = {0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xC0};


int i=0,j=0,firstOperand=0,secondOperand=0,entryToSecond=0;
uint8_t operation = 0;


uint8_t input[30] = {'\0'}; // Initialize input array
uint8_t indexz = 0;


void clock_init()
{
	// Enable clock for GPIOA (bit 2)
	RCC_GPIOA_CLK_EN();
	// Enable clock for GPIOB (bit 3)
	RCC_GPIOB_CLK_EN();

}

void GPIO_init()
{

	GPIO_PinConfig_t PinCfg;

	// Pins Configuration for 7 segment

	// a output push pull mode
	PinCfg.GPIO_PinNumber = a_7SEG;
	PinCfg.GPIO_MODE = GPIO_MODE_OUTPUT_PUSHPULL;
	PinCfg.GPIO_OUTPUT_SPEED = GPIO_SPEED_10MHZ;
	MCAL_GPIO_Init(SEVEN_SEG_PORT, &PinCfg);

	// b output push pull mode
	PinCfg.GPIO_PinNumber = b_7SEG;
	PinCfg.GPIO_MODE = GPIO_MODE_OUTPUT_PUSHPULL;
	PinCfg.GPIO_OUTPUT_SPEED = GPIO_SPEED_10MHZ;
	MCAL_GPIO_Init(SEVEN_SEG_PORT, &PinCfg);

	// c output push pull mode
	PinCfg.GPIO_PinNumber = c_7SEG;
	PinCfg.GPIO_MODE = GPIO_MODE_OUTPUT_PUSHPULL;
	PinCfg.GPIO_OUTPUT_SPEED = GPIO_SPEED_10MHZ;
	MCAL_GPIO_Init(SEVEN_SEG_PORT, &PinCfg);

	// d output push pull mode
	PinCfg.GPIO_PinNumber = d_7SEG;
	PinCfg.GPIO_MODE = GPIO_MODE_OUTPUT_PUSHPULL;
	PinCfg.GPIO_OUTPUT_SPEED = GPIO_SPEED_10MHZ;
	MCAL_GPIO_Init(SEVEN_SEG_PORT, &PinCfg);

	// e output push pull mode
	PinCfg.GPIO_PinNumber = e_7SEG;
	PinCfg.GPIO_MODE = GPIO_MODE_OUTPUT_PUSHPULL;
	PinCfg.GPIO_OUTPUT_SPEED = GPIO_SPEED_10MHZ;
	MCAL_GPIO_Init(SEVEN_SEG_PORT, &PinCfg);

	// f output push pull mode
	PinCfg.GPIO_PinNumber = f_7SEG;
	PinCfg.GPIO_MODE = GPIO_MODE_OUTPUT_PUSHPULL;
	PinCfg.GPIO_OUTPUT_SPEED = GPIO_SPEED_10MHZ;
	MCAL_GPIO_Init(SEVEN_SEG_PORT, &PinCfg);

	// g output push pull mode
	PinCfg.GPIO_PinNumber = g_7SEG;
	PinCfg.GPIO_MODE = GPIO_MODE_OUTPUT_PUSHPULL;
	PinCfg.GPIO_OUTPUT_SPEED = GPIO_SPEED_10MHZ;
	MCAL_GPIO_Init(SEVEN_SEG_PORT, &PinCfg);



}



uint32_t exponent(uint8_t base,uint8_t exp){
	uint32_t result = 1;
	while (exp != 0) {
		result = base * result;
		--exp;
	}
	return result;
}



int main(void)
{
	clock_init();
	GPIO_init();




	uint8_t Value;


	Lcd_ES_tsendString("Hello STM32");
	wait_ms(500);
	lcd_ES_tclear();

	for(uint8_t i=0;i<=10;i++)
	{
		MCAL_GPIO_WritePort(GPIOB, sevSegArray[i] << 8);
		wait_ms(1000);
	}


	Lcd_ES_tInit();
	KPD_init();
	lcd_ES_tclear();
	Lcd_ES_tsendString("Calculator ready");
	wait_ms(500);
	lcd_ES_tclear();

	while (1)
	{



		KPD_ES_tGetKeyPressed(&Value);
		if (Value != KPD_U8_NOT_PRESSED)
		{
			input[indexz] = Value; // Store input in array
			Lcd_ES_tsendChar(input[indexz]);
			indexz++; // Increment index

			switch (input[indexz - 1])
			{
			case '+':
			case '*':
			case '-':
			case '/':
				operation = input[indexz - 1];
				for (i = indexz - 2, j = 0; i >= 0; i--, j++)
				{
					firstOperand += ((input[i] - '0') * exponent(10, j));
				}
				entryToSecond = indexz;
				break;
			case '=':
				for (i = indexz - 2, j = 0; i >= entryToSecond; i--, j++)
				{
					secondOperand += ((input[i] - '0') * exponent(10, j));
				}
				LCD_ES_tGoTo(1, 0);
				switch (operation)
				{
				case '+':
					Lcd_ES_tdisplayNum(firstOperand + secondOperand);
					break;
				case '-':
					Lcd_ES_tdisplayNum(firstOperand - secondOperand);
					break;
				case '*':
					Lcd_ES_tdisplayNum(firstOperand * secondOperand);
					break;
				case '/':
					if(secondOperand == 0){
						lcd_ES_tclear();
						LCD_ES_tGoTo(0, 0);
						Lcd_ES_tsendString("ERROR: ");
						LCD_ES_tGoTo(1, 0);
						Lcd_ES_tsendString("Division by zero");
					}else{
						Lcd_ES_tdisplayNum(firstOperand / secondOperand);
					}
					break;
				}

				// Reset variables
				firstOperand = 0;
				secondOperand = 0;
				indexz = 0;

				break;
				case 'C':
					lcd_ES_tclear();
					firstOperand = 0;
					secondOperand = 0;
					indexz = 0;
					break;
			}
		}
	}
}



